{
    "pattern": "CREATE TABLE golang1 (fcbpdt CHAR (8) COLLATE utf8_general_ci <constraint_enforce_replace>, fcbpsq VARCHAR (20) COLLATE utf8_general_ci <constraint_enforce_replace>, procst CHAR (4) COLLATE utf8_general_ci DEFAULT <dml_values_parameter>, cipstx VARCHAR (105) COLLATE utf8_general_ci DEFAULT <dml_values_parameter>, cipsst CHAR (4) COLLATE utf8_general_ci DEFAULT <dml_values_parameter>, dyngtg VARCHAR(4) COLLATE utf8_general_ci DEFAULT <dml_values_parameter>, blncdt VARCHAR (8) COLLATE utf8_general_ci DEFAULT <dml_values_parameter>, PRIMARY KEY (fcbpdt, fcbpsq)); INSERT INTO golang1 VALUES (<dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>); CREATE TABLE golang2 (sysgrp VARCHAR(20) <constraint_enforce_replace>, procst VARCHAR(8) <constraint_enforce_replace>, levlid INT(11) <constraint_enforce_replace>, PRIMARY KEY (procst)); INSERT INTO golang2 VALUES (<dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>); INSERT INTO golang2 VALUES (<dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>); INSERT INTO golang2 VALUES (<dml_values_parameter>, <dml_values_parameter>, <dml_values_parameter>); UPDATE golang1 a SET procst = (CASE <case_parameter>), cipstx = <dml_values_parameter>, cipsst = <dml_values_parameter>, dyngtg = <dml_values_parameter>, blncdt = <dml_values_parameter> WHERE fcbpdt = <dml_values_parameter> AND fcbpsq = <dml_values_parameter>;",
    "applied_rules": [
        "<constraint_enforce_replace>",
        "<dml_values_parameter>",
        "<case_parameter>"
    ],
    "Affected Elements": "UPDATE, CASE, SELECT, WHERE",
    "Root Cause Analysis": "The update statement is failing due to an attempted access to an empty result set from the subquery, leading to an index out of range error."
}