{
    "pattern": "CREATE TABLE quarterly_report_status1 ( report_id INT <constraint_type_parameter>, report_status VARCHAR(20) <constraint_type_parameter>, report_updated TIMESTAMP(3) <constraint_type_parameter> ) PARTITION BY RANGE ( FLOOR(UNIX_TIMESTAMP(report_updated)*1000) ) ( PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00')*1000 ), PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00')*1000), PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00')*1000), PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00')*1000), PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00')*1000), PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00')*1000), PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00')*1000), PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00')*1000), PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00')*1000), PARTITION p9 VALUES LESS THAN (MAXVALUE) ); CREATE TABLE quarterly_report_status2 ( report_id INT <constraint_type_parameter>, report_status VARCHAR(20) <constraint_type_parameter>, report_updated TIMESTAMP(3) <constraint_type_parameter> ) PARTITION BY RANGE ( FLOOR(UNIX_TIMESTAMP(report_updated)) ) ( PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00')), PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ), PARTITION p2 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-07-01 00:00:00') ), PARTITION p3 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-10-01 00:00:00') ), PARTITION p4 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-01-01 00:00:00') ), PARTITION p5 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-04-01 00:00:00') ), PARTITION p6 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-07-01 00:00:00') ), PARTITION p7 VALUES LESS THAN ( UNIX_TIMESTAMP('2009-10-01 00:00:00') ), PARTITION p8 VALUES LESS THAN ( UNIX_TIMESTAMP('2010-01-01 00:00:00') ), PARTITION p9 VALUES LESS THAN (MAXVALUE) ); SET tidb_partition_prune_mode = <dml_values_parameter>; EXPLAIN ANALYZE SELECT COUNT(*) FROM quarterly_report_status1 AS h WHERE h.report_updated >= <where_parameter> AND h.report_updated < <where_parameter>; EXPLAIN ANALYZE SELECT COUNT(*) FROM quarterly_report_status2 AS h WHERE h.report_updated >= <where_parameter> AND h.report_updated < <where_parameter>;",
    "applied_rules": [
        "<constraint_type_parameter>",
        "<dml_values_parameter>",
        "<where_parameter>"
    ],
    "Affected Elements": "PARTITION BY RANGE, UNIX_TIMESTAMP, EXPLAIN ANALYZE",
    "Root Cause Analysis": "The difference in partitioning logic (using FLOOR(UNIX_TIMESTAMP(report_updated)*1000) vs. FLOOR(UNIX_TIMESTAMP(report_updated))) leads to different SQL execution plans."
}