{
    "sql": "set global tidb_partition_prune_mode='dynamic'; drop table if exists tt1; drop table if exists tt2; CREATE TABLE tt1 ( id INT NOT NULL, listid INT, name varchar(10) ) PARTITION BY LIST (listid) ( PARTITION p1 VALUES IN (1), PARTITION p2 VALUES IN (2), PARTITION p3 VALUES IN (3), PARTITION p4 VALUES IN (4) ); CREATE TABLE tt2 ( id INT NOT NULL, listid INT ); create index idx_listid on tt1(id,listid); create index idx_listid on tt2(listid); delete from tt1; delete from tt2; insert into tt1 values(1,1,'name1'); insert into tt1 values(2,2,'name2'); insert into tt1 values(3,3,'name3'); insert into tt1 values(4,4,'name4'); insert into tt2 values(1,1); insert into tt2 values(2,2); insert into tt2 values(3,3); insert into tt2 values(4,4); insert into tt2 values(5,5); analyze table tt1; analyze table tt2; explain analyze select /*+ inl_join(tt1)*/ count(*) from tt2 left join tt1 on tt1.listid=tt2.listid and tt1.id=tt2.id;",
    "Affected Elements": "PARTITION BY, VALUES IN, LEFT JOIN, ERROR 1526",
    "Root Cause Analysis": "The dynamic partition pruning mechanism does not handle cases where the partition for a value is missing, resulting in an error when attempting to locate the partition for the provided index values."
}