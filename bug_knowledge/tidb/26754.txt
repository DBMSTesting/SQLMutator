{
    "sql": "use test; drop table if exists t1, t3; create table t1 (a int, b tinyint, primary key (a)) partition by range (a) (partition p0 values less than (5), partition p1 values less than (20), partition p2 values less than (30), partition p3 values less than (40), partition p4 values less than MAXVALUE); insert into t1 values (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (20, 20), (21, 21), (22, 22), (23, 23), (24, 24), (25, 25), (30, 30), (31, 31), (32, 32), (33, 33), (34, 34), (35, 35), (36, 36), (40, 40), (50, 50), (80, 80), (90, 90), (100, 100); create table t3 (a int, b mediumint, primary key (a)); insert into t3 values (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10, 10), (11, 11), (12, 12), (13, 13), (14, 14), (15, 15), (16, 16), (17, 17), (18, 18), (19, 19), (20, 20), (21, 21), (22, 22), (23, 23); set tidb_partition_prune_mode=static; select * from t3 where t3.a <> ALL (select t1.a from t1 partition (p0)) order by t3.a; set tidb_partition_prune_mode=dynamic; select * from t3 where t3.a <> ALL (select t1.a from t1 partition (p0)) order by t3.a;",
    "Affected Elements": "SELECT, ALL, PARTITION",
    "Root Cause Analysis": "The issue arises when using the ALL operator with a subquery that references a specific partition, leading to inconsistent results due to partition pruning logic in TiDB."
}