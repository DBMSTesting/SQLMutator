{
    "sql": "set @@session.tidb_partition_prune_mode = 'dynamic'; drop table if exists t1, t2; create table t1 (c_int int, c_str varchar(40), primary key (c_int, c_str) clustered, key(c_int)) partition by hash (c_int) partitions 4; create table t2 like t1; insert into t1 values(6, 'beautiful curran'); insert into t1 values(7, 'epic kalam'); insert into t1 values(7, 'affectionate curie'); insert into t2 values(6, 'vigorous rhodes'); insert into t2 values(7, 'sweet aryabhata'); select * from t1, t2 where t1.c_int = t2.c_int and t1.c_str <= t2.c_str and t2.c_int in (6, 7, 6);",
    "Affected Elements": "SELECT statement, INNER JOIN, WHERE clause, partition pruning",
    "Root Cause Analysis": "The root cause of the bug appears to be an incorrect implementation of the index join, leading to duplicate results when the partition prune mode is set to dynamic."
}