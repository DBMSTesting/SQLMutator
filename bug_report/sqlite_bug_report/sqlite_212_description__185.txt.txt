PRAGMA temp.recursive_triggers = true;
CREATE TABLE t0(c0, c1 UNIQUE);
CREATE TRIGGER c DELETE ON t0
 BEGIN INSERT INTO t0(c1) VALUES(1);
END;
INSERT INTO t0(c1) VALUES(0);
REPLACE INTO t0(c1) VALUES (0);
SELECT t0.c1 BETWEEN 0 AND (CASE WHEN 1 THEN 1 ELSE t0.c0 END NOT NULL) FROM t0;

.echo on
.mode quote
PRAGMA temp.recursive_triggers = true;
CREATE TABLE t0(aa, bb);
CREATE UNIQUE INDEX t0bb ON t0(bb);
.imposter t0bb x1
CREATE TRIGGER r1 BEFORE DELETE ON t0
  BEGIN INSERT INTO t0(aa,bb) VALUES(99,1);
END;
INSERT INTO t0(aa,bb) VALUES(10,20);
SELECT rowid, * FROM t0;
SELECT * FROM x1;
.eqp trace
REPLACE INTO t0(aa,bb) VALUES(30,20);
.eqp off
SELECT rowid, * FROM t0;
SELECT * FROM x1;

PRAGMA recursive_triggers=ON;
CREATE TABLE t1(a, b UNIQUE, c UNIQUE);
INSERT INTO t1(a,b,c) VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4);
CREATE TRIGGER r1 AFTER DELETE ON t1 WHEN OLD.c<>3 BEGIN
  INSERT INTO t1(rowid,a,b,c) VALUES(100,100,100,3);
END;
REPLACE INTO t1(rowid,a,b,c) VALUES(200,1,2,3);
PRAGMA integrity_check;
