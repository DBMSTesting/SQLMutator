ID: 2162
Title: [Bug]: 多会话并发操作表数据，耦合多表update场景问题 || [Bug]: Multiple sessions concurrently operate table data, coupled with multi-table update scenario issues
Description:
**Describe the bug**
多会话并发操作表数据，耦合多表update场景问题，会存在结果集与mysql不一致问题

**Environment**
正常环境
  

**Fast Reproduce Steps(Required)**
1）session1中建表
drop table if exists t,t1;
create table t(a int, b int, c int);
create table t1(a int, b int, c int);
insert into t values(1, 1, 1),(2, 2,2),(3, 3,3);
insert into t1 values(300,300,300),(400,400,400);
2）session1中执行更新sql如下，但是暂不提交，
begin;
update t set b=1000;
3）session2中执行更新sql，如下
begin;
update t1,t set t.a=20+t1.a+t.b+t.a,t1.a=t1.a+t.b+t.a;
由于第2)步中事务未提交，而阻塞。
4）session1中，执行commit，提交事务；
5）session2中sql会退出阻塞状态，继续执行。

**Expected behavior**
![image](https://github.com/user-attachments/assets/f9b438f4-32d6-41a8-aa70-7bb721b5fdd3)


**Actual Behavior**
![image](https://github.com/user-attachments/assets/b6129db9-a08f-4f7a-9690-57a4c5117be7)

**Additional context**
请问下：
1）在session2中的多表语法，当取t1表第一行，和t1表所有行，t1表能看到session1中对t表修改；当重新取t1表第二行，和t表所有行（如第一行时），源码中是如何保证还能看到session1中对t表修改，而不是上一次自己修改后的值呢？

<!--This is a translation content dividing line, the content below is generated by machine, please do not modify the content below-->
---
**Describe the bug**
Multiple sessions concurrently operate table data, coupled with multiple table update scenarios, there may be inconsistencies between the result set and mysql.

**Environment**
normal environment
  

**Fast Reproduce Steps(Required)**
1) Create table in session1
drop table if exists t,t1;
create table t(a int, b int, c int);
create table t1(a int, b int, c int);
insert into t values(1, 1, 1),(2, 2,2),(3, 3,3);
insert into t1 values(300,300,300),(400,400,400);
2) Execute the update sql in session1 as follows, but do not submit it yet.
begin;
update t set b=1000;
3) Execute update sql in session2, as follows
begin;
update t1,t set t.a=20+t1.a+t.b+t.a,t1.a=t1.a+t.b+t.a;
Because the transaction in step 2) is not committed, it is blocked.
4) In session1, execute commit and submit the transaction;
5) SQL in session 2 will exit the blocking state and continue execution.

**Expected behavior**
![image](https://github.com/user-attachments/assets/f9b438f4-32d6-41a8-aa70-7bb721b5fdd3)


**Actual Behavior**
![image](https://github.com/user-attachments/assets/b6129db9-a08f-4f7a-9690-57a4c5117be7)

**Additional context**
Please ask:
1) In the multi-table syntax in session 2, when the first row of the t1 table is fetched, and all the rows of the t1 table, the t1 table can see the modifications to the t table in session1; when the second row of the t1 table is fetched, and all the rows of the t table are fetched again (For example, in the first line), how can the source code ensure that the modifications to the t table in session 1 can still be seen, instead of the values ​​modified last time?
