ID: 15341
Title: Queries with list_aggregate and unnest on same list value slow and memory-intensive; DuckDB should optimize by calculating the aggregate before unnesting.
Description:
### What happens?

A SELECT that applies `list_aggregate` and `unnest ` on the same list-typed value is very slow and memory-intensive. A rewrite (extra cte) that forces execution of the aggregate computation so it happens prior to unnesting operation is very much faster.

This suggests DuckDB re-executes the aggregation operation for each row generated by the unnesting operation. The request is to optimize such queries so that the list_aggregation is executed no more often than necessary.

### To Reproduce

Slow query:

```sql
with data as (
    SELECT range(100000) as arr
), cte1 as (
  SELECT list_aggregate(arr, 'COUNT') as arr_count
  ,      list_aggregate(arr, 'AVG')   as arr_avg
  ,      unnest(arr)
  FROM data
)
select * 
from cte1;
```

Equivalent fast query:

```sql
with data as (
    SELECT range(100000) as arr
), cte1 as (
  SELECT list_aggregate(arr, 'COUNT') as arr_count
  ,      list_aggregate(arr, 'AVG')   as arr_avg
  ,      arr
  FROM data
), cte2 as (
  SELECT arr_count
  ,      arr_avg
  ,      unnest(arr)
  FROM cte1
)
select * 
from cte2; 
```

### OS:

windows 11 enterprise

### DuckDB Version:

1.1.3

### DuckDB Client:

CLI, WASM (all)

### Hardware:

Laptop

### Full Name:

Roland Bouman

### Affiliation:

EPAM Systems BV Netherlands

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a stable release

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [X] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [X] Yes, I have