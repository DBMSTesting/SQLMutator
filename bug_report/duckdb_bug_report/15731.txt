ID: 15731
Title: The problem of inconsistent results for statements with the same semantics
Description:
### What happens?

I encountered inconsistency while executing the following SQL statement. I believe that statement 1 and statement 2 should return the same result,
The first query does not have a where condition, and the second query returns union all results for true, false, and unknown under the same condition. According to the three value logic, these two results should be the same, but in fact, they return different amounts of data.

### To Reproduce

```sql
CREATE TABLE t0(c0 INT1 DEFAULT(0.051298212901439655), c1 SIGNED DEFAULT(-185766140));
UPDATE t0 SET c0=false;
INSERT INTO t0(c1, c0) VALUES (DATE '1970-01-18', '');
INSERT INTO t0(c1) VALUES ('Z%jf-4䨎샐*');
INSERT INTO t0(c1) VALUES (1637497274), (TIMESTAMP '1970-01-08 18:16:49');
INSERT INTO t0(c0, c1) VALUES (1209294595, 0.665333338432057), (true, -1.427045858E9);
INSERT INTO t0(c0, c1) VALUES (DATE '1970-01-25', 700530425);
INSERT INTO t0(c0) VALUES ('0.08157374931989991');
EXPLAIN SELECT ((1725861978) IS NULL) FROM t0 GROUP BY ((-698137268)=((CASE t0.c1 WHEN ((t0.c1) IS NOT NULL) THEN TIMESTAMP '1969-12-13 00:06:47' WHEN t0.c1 THEN (t0.rowid BETWEEN false AND t0.rowid) WHEN (NOT 1092112508) THEN 0.41588998670944355 ELSE (DATE '1969-12-22' NOT IN (DATE '1970-01-16', TIMESTAMP '1969-12-19 19:47:02', t0.rowid)) END ))) ORDER BY t0.rowid DESC, t0.c1 DESC, t0.c0 OFFSET 368556399;
EXPLAIN SELECT (((((DATE '1970-01-05') COLLATE C) LIKE ((TIMESTAMP '1970-01-24 20:43:38') COLLATE NOACCENT) ESCAPE DEGREES(TIMESTAMP '1969-12-16 07:30:16'))) COLLATE NOACCENT.NOCASE), t0.rowid, ((CEIL(((((TIMESTAMP '1970-01-02 12:34:33')=((DATE '1970-01-12' NOT IN (DATE '1969-12-13'))))) COLLATE POSIX))) ::DOUBLE), ATAN((((t0.c1) ::VARCHAR) IN (t0.rowid, '', '-260551495'))), (DATE '1969-12-18' BETWEEN t0.c0 AND -1.912206964E9) FROM t0 GROUP BY false;
EXPLAIN SELECT 0.26141173206399637 FROM t0 GROUP BY t0.c1 HAVING TIMESTAMP '1969-12-27 23:40:39' LIMIT 790608032 OFFSET 1145475972;
CREATE VIEW v82(c0) AS SELECT 0.4823426752378228 FROM t0 WHERE ((t0.rowid) COLLATE NOACCENT) GROUP BY t0.c0 ORDER BY t0.c1 LIMIT 396670862;
CREATE VIEW v0(c0) AS SELECT POWER(t0.rowid) FROM t0 ORDER BY ((t0.c0 IN (285743366)) NOT IN (t0.rowid, ((CASE t0.c1 WHEN t0.rowid THEN t0.c0 ELSE t0.c0 END ) NOT IN (((t0.rowid) COLLATE NOACCENT))), SIGN(t0.rowid))) DESC OFFSET 1664200974;
CREATE VIEW v0(c0) AS SELECT (((((t0.c1) IS NULL)) COLLATE C) NOT BETWEEN t0.c0 AND t0.rowid) FROM t0 GROUP BY (((((false NOT BETWEEN DATE '1970-01-17' AND t0.rowid))AND((0.8508231364418466 LIKE t0.c1 ESCAPE TIMESTAMP '1969-12-13 00:06:47'))))=((t0.c1 LIKE ((1556207546)AND(716355460)) ESCAPE STRIP_ACCENTS(((t0.c0)<=(t0.rowid)))))) HAVING 1105789912 ORDER BY (-1472134993 LIKE (((t0.c0) IS NOT NULL) LIKE TIMESTAMP '1970-01-08 15:11:40' ESCAPE '') ESCAPE (NOT LOG2((+ ((t0.c1)<(t0.c1)))))) DESC, 0.09348532413516641, ((t0.c0)OR((((TIMESTAMP '1969-12-15 07:04:25') COLLATE NOCASE) LIKE ((false)-(t0.c1)) ESCAPE 1954262672)));
CREATE VIEW v0(c0) AS SELECT t0.rowid FROM t0 WHERE ((true) IS NULL) GROUP BY t0.rowid ORDER BY (TAN((((t0.rowid)>=(((t0.c0)AND(t0.c0)))) BETWEEN t0.c0 AND (((t0.c0) ::DATE) LIKE t0.c0 ESCAPE (NOT NULL)))) NOT BETWEEN -594284220 AND t0.c0) ASC, (((('fZ')<<(((t0.c1)AND(t0.rowid)))))>>(SUFFIX((((NOT t0.c0)) ::TINYINT), DATE '1969-12-29'))), '' LIMIT 1823044550;
CREATE VIEW v0(c0, c1, c2) AS SELECT (((-1.988541363E9 BETWEEN ((t0.rowid)!~(t0.c1)) AND t0.c0)) ::BOOL), t0.c0, -645448897 FROM t0 HAVING t0.c0;
CREATE VIEW v0(c0) AS SELECT ((t0.rowid) IS NOT NULL) FROM t0 GROUP BY (2141107263 NOT BETWEEN ((t0.c1)~((t0.c1 IN ('L', 0.773823868621045, 1012722309)))) AND -1797678708), TIMESTAMP '1969-12-24 20:41:20', (t0.rowid NOT BETWEEN REGEXP_MATCHES((CASE (('fㅞ욏v杶HB0|') COLLATE POSIX) WHEN (+ ((-375560093) ::VARCHAR)) THEN ((1152670626) COLLATE NOACCENT.NOCASE) WHEN t0.rowid THEN (('-1819092976')>=(LAST_DAY((t0.c1 NOT IN (t0.c1))))) WHEN t0.c1 THEN TIMESTAMP '1969-12-14 18:02:15' ELSE (t0.rowid LIKE ('-1377453319' NOT BETWEEN t0.c1 AND t0.rowid) ESCAPE (true LIKE 'T_鯡鷅m{dx' ESCAPE 'ꅵq*1*gys<')) END ), (t0.c1 LIKE t0.rowid ESCAPE ((0.9189794756048154)*((CASE t0.c1 WHEN t0.rowid THEN t0.c1 ELSE t0.rowid END ))))) AND 0.15459331710328073) HAVING DEGREES(t0.rowid);
CREATE VIEW v0(c0) AS SELECT t0.rowid FROM t0 WHERE 0.9268147670313996 ORDER BY t0.c1 DESC, TIMESTAMP '1970-01-17 01:38:09' DESC, t0.rowid ASC LIMIT 824793399 OFFSET 22399636;
CREATE INDEX i2 ON t0(c0 );
INSERT INTO t0(c0) VALUES (false), (-1427045858);
INSERT INTO t0(c0) VALUES (0.345533146443321);
UPDATE t0 SET c0=-1148980465, c1=false;
UPDATE t0 SET c0=DATE '1970-01-09', c1=-1247243502;
UPDATE t0 SET c1=true, c0=DATE '1970-01-21';
UPDATE t0 SET c0=-4.41278572E8;
UPDATE t0 SET c0=DATE '1970-01-22', c1=1322747524;
UPDATE t0 SET c1=-1736770258, c0=0.18558799648579727;
INSERT INTO t0(c1) VALUES (0.2412596706190676);
VACUUM;
INSERT INTO t0(c0) VALUES (DEFAULT), (DATE '1970-01-10');
INSERT INTO t0(c0, c1) VALUES (-785113987, DATE '1969-12-12');
INSERT INTO t0(c1) VALUES (DATE '1970-01-07'), (TIMESTAMP '1969-12-25 04:32:11');
INSERT INTO t0(c1, c0) VALUES ('hf䣇X	){?', '');
INSERT INTO t0(c1) VALUES ('1_');
INSERT INTO t0(c0) VALUES (TIMESTAMP '1969-12-26 23:44:16');
INSERT INTO t0(c0) VALUES (DATE '1970-01-19'), (1.912659599E9);
INSERT INTO t0(c1) VALUES (TIMESTAMP '1970-01-11 17:58:35'), (DEFAULT);
INSERT INTO t0(c0, c1) VALUES (0.035204219202959686, 0.8463024735388358), (TIMESTAMP '1970-01-17 05:55:03', TIMESTAMP '1970-01-04 16:41:39');
INSERT INTO t0(c0) VALUES (788619800), (-1702331977);
INSERT INTO t0(c1) VALUES (true), (0.37340505447970596);
INSERT INTO t0(c1) VALUES (TIMESTAMP '1969-12-27 03:15:39');
INSERT INTO t0(c1, c0) VALUES (2.132864697E9, 1567189628);
INSERT INTO t0(c0, c1) VALUES (true, false);
INSERT INTO t0(c0) VALUES (DATE '1970-01-17');
INSERT INTO t0(c1) VALUES ('\'), (DATE '1969-12-12'), (DATE '1970-01-13');
INSERT INTO t0(c1) VALUES (false), (134824512);
CREATE UNIQUE INDEX i0 ON t0(c1 , c0 , rowid );
CREATE UNIQUE INDEX i3 ON t0(c0 ASC, c1 );
CREATE INDEX i2 ON t0(c1 );
CREATE INDEX i4 ON t0(c0 );
INSERT INTO t0(c0, c1) VALUES ('', DATE '1970-01-14'), (DATE '1970-01-22', '');
INSERT INTO t0(c0) VALUES (182960197);
INSERT INTO t0(c0, c1) VALUES (1217396172, '');
INSERT INTO t0(c1, c0) VALUES (false, 1315767279);
INSERT INTO t0(c0, c1) VALUES ('U', 0.7295832525453051);
INSERT INTO t0(c1) VALUES (TIMESTAMP '1969-12-20 18:49:51');
INSERT INTO t0(c1, c0) VALUES (0.34793705611931247, DATE '1969-12-20'), (DEFAULT, 3.61635042E8);
INSERT INTO t0(c1, c0) VALUES (true, 192205239);
INSERT INTO t0(c1) VALUES (DATE '1969-12-24');
INSERT INTO t0(c1) VALUES (0.45268726615221344);
INSERT INTO t0(c1, c0) VALUES ('|', true);
INSERT INTO t0(c1, c0) VALUES (true, 2132864697);
INSERT INTO t0(c1) VALUES (1640241679);
```

First query:
```sql
SELECT t0.c1, t0.rowid, t0.c0 FROM t0
```
whose cardinality is: 10

Second query:
```sql
SELECT t0.c1, t0.rowid, t0.c0 FROM t0 WHERE ((((((-1072040478) IS NULL)) IS NOT NULL))<(t0.c0)) UNION ALL SELECT t0.c1, t0.rowid, t0.c0 FROM t0 WHERE (NOT ((((((-1072040478) IS NULL)) IS NOT NULL))<(t0.c0))) UNION ALL SELECT t0.c1, t0.rowid, t0.c0 FROM t0 WHERE ((((((((-1072040478) IS NULL)) IS NOT NULL))<(t0.c0))) IS NULL)
```
whose cardinality is: 9

### OS:

linux

### DuckDB Version:

v1.1.4-dev3162

### DuckDB Client:

python

### Hardware:

_No response_

### Full Name:

Chenglin

### Affiliation:

personal

### What is the latest build you tested with? If possible, we recommend testing with the latest nightly build.

I have tested with a source build

### Did you include all relevant data sets for reproducing the issue?

Yes

### Did you include all code required to reproduce the issue?

- [x] Yes, I have

### Did you include all relevant configuration (e.g., CPU architecture, Python version, Linux distribution) to reproduce the issue?

- [x] Yes, I have